{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Utils_1 = require(\"../../Utils/Utils\");\n\nvar CollisionMode_1 = require(\"../../../Enums/CollisionMode\");\n\nvar Collider = function () {\n  function Collider() {}\n\n  Collider.collide = function (p1, container) {\n    for (var _i = 0, _a = container.particles.spatialGrid.queryRadius(p1.position, p1.size.value * 2); _i < _a.length; _i++) {\n      var p2 = _a[_i];\n\n      if (p1 === p2 || !p2.particlesOptions.collisions.enable || p1.particlesOptions.collisions.mode !== p2.particlesOptions.collisions.mode) {\n        continue;\n      }\n\n      var dist = Utils_1.Utils.getDistanceBetweenCoordinates(p1.position, p2.position);\n      var defaultSize = container.retina.sizeValue;\n      var radius1 = this.getRadius(p1, defaultSize);\n      var radius2 = this.getRadius(p2, defaultSize);\n      var distP = radius1 + radius2;\n\n      if (dist <= distP) {\n        this.resolveCollision(p1, p2);\n      }\n    }\n  };\n\n  Collider.getRadius = function (particle, fallback) {\n    return particle.bubble.radius || particle.size.value || fallback;\n  };\n\n  Collider.resolveCollision = function (p1, p2) {\n    switch (p1.particlesOptions.collisions.mode) {\n      case CollisionMode_1.CollisionMode.bounce:\n        var xVelocityDiff = p1.velocity.horizontal - p2.velocity.horizontal;\n        var yVelocityDiff = p1.velocity.vertical - p2.velocity.vertical;\n        var xDist = p2.position.x - p1.position.x;\n        var yDist = p2.position.y - p1.position.y;\n\n        if (xVelocityDiff * xDist + yVelocityDiff * yDist >= 0) {\n          var angle = -Math.atan2(p2.position.y - p1.position.y, p2.position.x - p1.position.x);\n          var m1 = p1.size.value;\n          var m2 = p2.size.value;\n          var u1 = this.rotate(p1.velocity, angle);\n          var u2 = this.rotate(p2.velocity, angle);\n          var v1 = {\n            horizontal: u1.horizontal * (m1 - m2) / (m1 + m2) + u2.horizontal * 2 * m2 / (m1 + m2),\n            vertical: u1.vertical\n          };\n          var v2 = {\n            horizontal: u2.horizontal * (m1 - m2) / (m1 + m2) + u1.horizontal * 2 * m2 / (m1 + m2),\n            vertical: u2.vertical\n          };\n          var vFinal1 = this.rotate(v1, -angle);\n          var vFinal2 = this.rotate(v2, -angle);\n          p1.velocity.horizontal = vFinal1.horizontal;\n          p1.velocity.vertical = vFinal1.vertical;\n          p2.velocity.horizontal = vFinal2.horizontal;\n          p2.velocity.vertical = vFinal2.vertical;\n        }\n\n    }\n  };\n\n  Collider.rotate = function (velocity, angle) {\n    return {\n      horizontal: velocity.horizontal * Math.cos(angle) - velocity.vertical * Math.sin(angle),\n      vertical: velocity.horizontal * Math.sin(angle) + velocity.vertical * Math.cos(angle)\n    };\n  };\n\n  return Collider;\n}();\n\nexports.Collider = Collider;","map":{"version":3,"sources":["/home/jhon/Web/iTresse/itresse-landing/node_modules/tsparticles/dist/Classes/Interactions/Particles/Collider.js"],"names":["Object","defineProperty","exports","value","Utils_1","require","CollisionMode_1","Collider","collide","p1","container","_i","_a","particles","spatialGrid","queryRadius","position","size","length","p2","particlesOptions","collisions","enable","mode","dist","Utils","getDistanceBetweenCoordinates","defaultSize","retina","sizeValue","radius1","getRadius","radius2","distP","resolveCollision","particle","fallback","bubble","radius","CollisionMode","bounce","xVelocityDiff","velocity","horizontal","yVelocityDiff","vertical","xDist","x","yDist","y","angle","Math","atan2","m1","m2","u1","rotate","u2","v1","v2","vFinal1","vFinal2","cos","sin"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Utils_1 = require(\"../../Utils/Utils\");\nvar CollisionMode_1 = require(\"../../../Enums/CollisionMode\");\nvar Collider = (function () {\n    function Collider() {\n    }\n    Collider.collide = function (p1, container) {\n        for (var _i = 0, _a = container.particles.spatialGrid.queryRadius(p1.position, p1.size.value * 2); _i < _a.length; _i++) {\n            var p2 = _a[_i];\n            if (p1 === p2 || !p2.particlesOptions.collisions.enable ||\n                p1.particlesOptions.collisions.mode !== p2.particlesOptions.collisions.mode) {\n                continue;\n            }\n            var dist = Utils_1.Utils.getDistanceBetweenCoordinates(p1.position, p2.position);\n            var defaultSize = container.retina.sizeValue;\n            var radius1 = this.getRadius(p1, defaultSize);\n            var radius2 = this.getRadius(p2, defaultSize);\n            var distP = radius1 + radius2;\n            if (dist <= distP) {\n                this.resolveCollision(p1, p2);\n            }\n        }\n    };\n    Collider.getRadius = function (particle, fallback) {\n        return particle.bubble.radius || particle.size.value || fallback;\n    };\n    Collider.resolveCollision = function (p1, p2) {\n        switch (p1.particlesOptions.collisions.mode) {\n            case CollisionMode_1.CollisionMode.bounce:\n                var xVelocityDiff = p1.velocity.horizontal - p2.velocity.horizontal;\n                var yVelocityDiff = p1.velocity.vertical - p2.velocity.vertical;\n                var xDist = p2.position.x - p1.position.x;\n                var yDist = p2.position.y - p1.position.y;\n                if (xVelocityDiff * xDist + yVelocityDiff * yDist >= 0) {\n                    var angle = -Math.atan2(p2.position.y - p1.position.y, p2.position.x - p1.position.x);\n                    var m1 = p1.size.value;\n                    var m2 = p2.size.value;\n                    var u1 = this.rotate(p1.velocity, angle);\n                    var u2 = this.rotate(p2.velocity, angle);\n                    var v1 = {\n                        horizontal: u1.horizontal * (m1 - m2) / (m1 + m2) + u2.horizontal * 2 * m2 / (m1 + m2),\n                        vertical: u1.vertical,\n                    };\n                    var v2 = {\n                        horizontal: u2.horizontal * (m1 - m2) / (m1 + m2) + u1.horizontal * 2 * m2 / (m1 + m2),\n                        vertical: u2.vertical,\n                    };\n                    var vFinal1 = this.rotate(v1, -angle);\n                    var vFinal2 = this.rotate(v2, -angle);\n                    p1.velocity.horizontal = vFinal1.horizontal;\n                    p1.velocity.vertical = vFinal1.vertical;\n                    p2.velocity.horizontal = vFinal2.horizontal;\n                    p2.velocity.vertical = vFinal2.vertical;\n                }\n        }\n    };\n    Collider.rotate = function (velocity, angle) {\n        return {\n            horizontal: velocity.horizontal * Math.cos(angle) - velocity.vertical * Math.sin(angle),\n            vertical: velocity.horizontal * Math.sin(angle) + velocity.vertical * Math.cos(angle),\n        };\n    };\n    return Collider;\n}());\nexports.Collider = Collider;\n"]},"metadata":{},"sourceType":"script"}